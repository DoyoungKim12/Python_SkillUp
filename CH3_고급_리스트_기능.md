# 3. 고급 리스트 기능
파이썬의 가장 기초적인 컬렉션 클래스인 리스트는 다른 언어에서 제공하는 배열의 모든 기능 + 추가 기능을 제공한다.
<br>

## 3.1 파이썬 리스트 생성 및 활용
- 리스트의 생성은 다른 데이터를 만드는 방법과 동일함
  - 컬렉션을 구축하는 다른 방법 : append
  - remove로 항목 삭제도 가능 (삭제하려고 하는 값 중 첫번째로 등장하는 값을 삭제)
<br>

## 3.2 리스트 복사 vs 리스트 변수 복사
- 파이썬의 변수는 C++의 '값' 보다는 '참조'에 가까움 (한 컬렉션을 제대로 복사하려면 추가작업이 필요하다는 의미)
```python
a_list = [1,2,3]  # 대입 연산자(=)의 우측에 있는 값으로 리스트 생성 
b_list = a_list   # 새로운 데이터가 생성된 것이 아님 (a_list가 참조하고 있는 객체를 위한 별칭 b_list를 만든 것일 뿐)
```
- 전체 항목을 별도로 복사하려면 항목 간 복사(member-by-member)를 수행해야 함
  - 슬라이싱을 사용하는 것이 가장 간편 (b_list = a_list\[:])
<br>

## 3.3 인덱스
- 파이썬은 0을 포함한 양수와 음수 인덱스(색인)를 제공
- 리스트는 변경이 가능하므로, 전체 리스트를 재생성할 필요 없이 메모리에 있는 객체를 바로 수정할 수 있음
  - my_list\[0] = 5

### 3.3.1 양수 인덱스
### 3.3.2 음수 인덱스
### 3.3.3 enumerate 함수로 인덱스 숫자 생성
  - enumerate(이터러블, 시작=0) : 시작 값을 조정하여 1부터 시작하게 할 수도 있다
<br>

## 3.4 조각으로부터 데이터 가져오기
- 인덱스를 사용하면 한번에 하나의 항목만 가져오지만, 슬라이싱을 사용하면 구체적인 범위의 하위 리스트 생성이 가능함
<br>

## 3.5 조각 안에 값 대입하기
- 리스트의 특정 구간을 슬라이싱으로 지정하여 값을 대입할 수 있음
<br>

## 3.6 리스트 연산자
- 리스트에 적용되는 내장(built-in) 연산자를 요약한 것
  - +, \*, =, in, <, > 등
  - 부등호 관련 연산자는 항목간 비교를 수행
<br>

## 3.7 얕은 복사 vs 깊은 복사
- 얕은 복사 : 항목 간 복사를 하더라도, 항목 중 리스트가 있었다면 해당 내부 리스트의 참조를 복사한 것!
- 깊은 복사 : copy 패키지를 import하여 copy.deepcopy()를 사용
<br>

## 3.8 리스트 함수
- len, max, min, reversed, sorted, sum
- 메서드는 리스트 값을 바로 변경하는 반면, 함수는 새로운 리스트를 생성함
<br>

## 3.9 리스트 메서드 : 리스트 수정하기
- 새로운 리스트를 생성하는 대신 데이터를 직접 수정하는 메서드
  - 리스트.append(값)
  - 리스트.clear() : 모든 항목 제거
  - 리스트.extend(이터러블) : 하위 리스트 추가 (append랑 비슷하지만, 한꺼번에 여러 항목을 추가 가능)
  - 리스트.insert(인덱스, 값) : 인덱스 위치에 값 삽입
  - 리스트.remove(값) : 값의 첫 인스턴스 제거
<br>

## 3.10 리스트 메서드 : 내용 정보 가져오기
- 리스트의 정보를 반환하는 메서드
  - 리스트.count(값) : 해당 인스턴스의 개수
  - 리스트.index(값, \[, 시작 \[, 종료]]) : 특정 값이 처음 등장하는 인덱스 
  - 리스트.pop(\[인덱스]) : 인덱스의 값을 반환 및 제거, 기본값은 마지막 인덱스
<br>

## 3.11 리스트 메서드 : 재편성하기
- 리스트의 항목 순서를 변경하는 메서드
  - 리스트.sort(\[key=None], \[, reverse=False]) : key에는 특정 함수를 넣어, 함수의 결과값으로 sort할 수 있다!
  - 리스트.reverse()
<br>

## 3.12 스택 역할을 하는 리스트 : RPN 애플리케이션
> RPN : 역폴란드 표기법(RPN, reverse Polish notation) 또는 후위 표기법(후치 표기법)은 연산자를 연산 대상의 뒤에 쓰는 연산 표기법이다.
- 스택 메커니즘인 후입선출 장치로 리스트를 활용할 수 있는데, 이 때 append와 pop이 유용하다
  - 후입선출 : list 끝에 추가된 값은 빠질 때 가장 먼저 빠지는 것
```python
stk = [0]
stk.append(10)
stk.append(20)
stk.pop()  # 20이 제거됨
stk.pop()  # 10이 제거됨
```
- 스택 장치의 가장 유용한 데모 : 후위표기법 언어 번역 프로그램
  - 7+3을 7 3 +로 표기하는 것
  - 괄호 없이도 우선순위가 명확한 연산식 표현이 가능한 장점이 있음
<br>

## 3.13 reduce 함수
- functool 패키지의 여러 함수를 사용하면 리스트를 다양한 방식으로 처리할 수 있음
- functool.reduce 함수로 리스트의 전체 항목을 처리할 함수 적용이 가능
   - functool.reduce(함수, 리스트)
   - reduce 함수는 
    - 인수로 주어진 '함수'를 리스트 안에서 서로 이웃한 2개 항목(a1, a2)에 적용하여 연산(a1\*a2 = b1)하고,  
    - 그 결과를 누적하여 다시 인수로 넘기는(b1, a3) 과정을 반복함 (맨 앞의 쌍부터 차례대로 반복해오는 형태)
    - 따라서 '함수'는 반드시 2개의 인수를 가져야 하고, 결과값을 반환해야 함
<br>

## 3.14 람다 함수
- 단순한 1회용 함수를 만들 때 사용
- lambda 인수들: 반환값
  - 코드 실행결과는 저장되거나 직접 사용할 수 없는 콜러블(callable) : 런타임시 생성, 다시 참조하고 싶으면 변수에 대입
  - 변수에 대입해 이름을 지어줄 수도 있으나, 일반적인 사용방식은 아님
  - reduce 등 간단한 함수를 인수로 받는 함수에서 사용될 때 빛을 발함
<br>

## 3.15 리스트 함축(comprehension)
- 리스트 함축이 하는 일 : 모든 항목을 대상으로 항목 간 복사를 수행하는 것
- \[ 값 for_문_표현식 if_조건문 ]
<br>
  
## 3.16 딕셔너리와 세트의 함축
- 리스트 함축의 원칙은 세트와 딕셔너리까지 확장됨
  - 세트 : 대괄호를 중괄호로 바꿔주면 됨
  - 딕셔너리 : key:value의 쌍을 생성하는 식으로 표현
    - my_dict = {i[0]:i[1] for i in vals_list}
    - 키와 값이 서로 바뀐 새로운 딕셔너리를 생성할 때 유용함
<br>

## 3.17 리스트를 통한 인수 전달하기
- 파이썬의 인수 값은 참조 혹은 값에 의해 전달되는 것이 아니라, 인수 이름과 값이 연결된 데이터-딕셔너리 엔트리로 전달됨
- 이는 인수로 주어진 변수를 '함수 안에서' 수정할 수 없다는 의미
- 그러나 리스트는 문자열이나 튜플과는 달리 가변의 성질을 가지므로 함수 안에서 변경이 가능함
  - 슬라이싱과 인덱싱으로 가능
  - 리스트로 인수를 전달하여, 함수의 아웃풋을 변형된 리스트로 받아보는 것이 가능하다는 것
    ```python
    def set_list_vals(list_arg):
      list_arg[0] = 100
      list_arg[1] = 200
      list_arg[2] = 300
      
    a_list = [0,0,0]
    set_list_vals(a_list)
    print(a_list) # [100,200,300] 출력
    ```
  - 인덱스로 특정한 항목이나 슬라이싱으로 특정한 하위 리스트를 변경한다고 해서 변수가 참조하는 객체가 변하는 것은 아님
  - 그러나, 특정 값을 대입하는 식으로는 동작하지 않음 (함수 내부에서 새로운 리스트를 만드는 셈이 되기 때문)
<br>

## 3.18 다차원 리스트

### 3.18.1 불균형 행렬
### 3.18.2 제멋대로 큰 행렬 만들기
- 행렬_이름 = \[\[초깃값] * 열_갯수 for 행_번호 in range(행_갯수)]
<br>


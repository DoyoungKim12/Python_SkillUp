# 8. 텍스트와 바이너리 파일
- 파이썬은 파일을 읽고 쓰는 다양한 방법을 제공한다.
- 이 장에서는 raw 데이터, 혹은 바이너리 데이터를 읽고 쓰는 방법을 알아볼 것이다.
<br>

## 8.1 두 가지 종류의 파일 : 텍스트와 바이너리
- 파이썬은 텍스트와 바이너리 파일 간에 큰 차이점이 있다.
  - 저수준(low-level)의 파일-접근 모드
  - 파이썬은 텍스트 파일 모드에서 아스키 문자와 유니코드 인코딩을 지원하는 표준 파이썬 문자열을 사용하여 읽기/쓰기를 수행해야 한다.
    - 바이너리 연산은 원시 바이트를 보장하는 byte 클래스를 사용해야 한다.
  - 텍스트 쓰기는 숫자 데이터를 문자열 포맷으로 변환하는 것을 포함한다.
<br>

### 8.1.1 텍스트 파일
- 텍스트 데이터는 데이터 대부분이 텍스트 문자열로 구성된 파일이다.
  - 모든 데이터는 숫자 데이터를 포함하여 텍스트 편집기로 읽고 쓸 수 있다.
  - 장점은 범용적으로 사용된다는 것, 개행 문자에 의해 텍스트 줄이 구분되는 간단한 포맷을 가지고 있다는 점
  - 데이터 파일이 대량의 데이터 또는 숫자만 가지고 있다면 바이너리 포맷이 성능상 몇 배 빠를 수 있다. (숫자를 텍스트로, 텍스트를 숫자로 변환하는 시간 비용이 들지 않아서)
<br>

### 8.1.2 바이너리 파일
- 바이너리 파일과 텍스트 파일의 가장 큰 차이점은 숫자를 읽고 쓸 때 나타난다.
  - 텍스트 파일에서 각 바이트는 하나의 문자로 구성된다. (숫자 1000을 표현할 때, 한 개의 1과 3개의 0이 필요)
  - 바이너리 모드를 사용하면, 숫자 1000은 숫자 값(4바이트 정수)에 직접 쓰게 된다.
  - 장점은 속도를 올리고 크기를 줄인다는 것이다.
  - 단점은 데이터를 표현한 특정 포맷을 이해해야 한다는 점이다.
<br>

## 8.2 바이너리 파일을 사용하는 경우 : 요약
- 파이썬은 고수준 객체를 다루는 반면, 바이너리 파일은 raw 데이터로 구성되어 있어 문제가 발생한다.
  - 예를 들어, 파이썬 언어는 잠재적으로 매우 큰 정수를 사용할 수 있는데, 이를 저장하려면 많은 바이트가 필요하다.
  - 이런 정수를 파일에 기록하려면 얼마만큼의 바이트를 사용할지 정확히 결정해야 한다.
<br>

- 이러한 문제를 해결하기 위한 패키지들이 존재한다.
  - bytes 문자열에 직접 인코딩하여 바이트를 읽고 쓴다.
  - struct 패키지로 숫자와 문자열 저장소를 표준화, 일관성있게 읽고 쓴다.
  - 고수준 파이썬 객체로 항목을 읽고 쓰기 위해 pickle 패키지를 사용한다. 
  - 전체 데이터 파일을 하나의 큰 데이터 딕셔너리(파이썬 객체)로 다루기 위해 shelve 패키지를 사용한다.
<br>

## 8.3 파일/디렉터리 시스템
- OS(운영체제) 패키지 : 제어 프로세스와 함께 파일/디렉터리 시스템을 면밀히 살펴볼 수 있다.
  - 프로세스 시작, 종료, 반복 : spawn, kill, abort, fork(기존 프로세스 기반으로 신슈 프로세스 파생)
  - 파일/디렉터리 시스템을 변경하거나 탐색 : rename, removedirs, chroot, getwcd(현재 작업 디렉터리 반환), rmdir(디렉터리 제거), listdir, makedir, mkdir
  - 파일 플래그와 다른 속성들을 수정하는 함수 : chflags, chmod, chown
  - 환경 변수를 가져오거나 조정하는 함수 : getenv, getenvb, putenv
  - 신규 시스템 명령어 실행 : exec~
  - 파일 I/O에 저수준 접근을 가능하게 하는 함수 : open, read, write가 이 함수 기반으로 만들어짐
<br>

## 8.4 파일을 열 때 발생하는 예외 다루기
```python

# 대괄호 안의 텍스트는 선택사항
# else 조건은 첫번째 블록문이 예외 없이 잘 실행될 경우 실행됨
# finally 조건은 다른 모든 블록이 실행되고 나서 반드시 실행됨

try:
  문장_블록_1
except 예외_클래스_A:
  문장_블록_A
[except 예외_클래스_B:
  문장_블록_B]
[else:
  문장_블록_2]
[finally:
  문장_블록_3]
```

<br>

## 8.5 'with' 키워드 사용하기
- with문은 파일을 열어 변수로 파일에 접근할 수 있게 해준다.
  - 만약 블록문을 수행하는 도중 예외가 발생하면 파일은 자동적으로 닫히며, 파일 핸들러가 열린 채로 남지 않게 된다.
  - with open(파일_이름, 모드_문자열) as 파일_객체: 문장
<br>

## 8.6 읽기/쓰기 연산의 요약
- 텍스트, 바이너리, 피클 파일을 읽거나 쓸 때 사용하는 기본 문법 요약
  - file = open(name, mode) : 파일을 읽거나 쓰기, 텍스트모드 w,r과 바이너리모드 wb, rb를 모두 포함
  - str = file.readline(size=1) : 텍스트-파일 읽기 연산, 텍스트의 다음 줄을 개행 문자가 나올때까지 읽어 문자열로 반환
  - list = file.readlines() : 텍스트-파일 읽기 연산, 파일 안의 모든 텍스트를 읽어 텍스트 1줄이 각각의 항목으로 구성된 리스트를 반환
  - str = file.read(size=-1) : 바이너리-파일 읽기, 파일의 내용을 읽고 문자열로 반환
  - file.write(text) : 텍스트 혹은 바이너리 쓰기 연산, 쓰기를 한 바이트 개수인 문자열의 길이를 반환
  - file.writelines(str_list) : 텍스트 모드에서 사용하는 쓰기 연산, 나열된 문자열을 입력
  - file.writable() : 파일을 수정할 수 있으면 True를 반환
  - file.seek(pos, orig) : 파일 내 파일포인터를 지시한 위치로 이동, orig에서 pos만큼 이동
  - file.seekable() : 파일 시스템이 임의 접근을 제공하면 True를 반환
  - file.tell() : 현재 파일 위치를 반환, 파일 시작 지점의 바이트 개수를 반환
  - file.close() : 파일을 닫고 I/O버퍼를 비워 지연되어있던 모든 읽기/쓰기 연산을 파일에 반영
  - pickle.dump(obj, file) : 피클링과 함께 사용, 바이너리 객체인 obj의 내용을 바이너리 포맷으로 만들어주고 주어진 file에 그 내용을 기록
  - pickle.dumps(obj) : 피클링과 함께 사용, obj의 바이너리 표현을 바이트 서식으로 반환
  - pickle.load(file) : 피클링과 함께 사용, pickle.dump 메서드로 파일에 작성한 객체를 반환
<br>

## 8.7 텍스트 파일 작업 상세하게 알아보기
- 파일을 읽고 쓸 때 사용하는 메서드
  - 문자열 = 파일.read(size=-1)
    - 파일의 전체내용을 읽어 하나의 문자열로 반환, size는 읽을 문자의 최대 개수
  - 문자열 = 파일.readline(size=-1)
    - 첫 개행문자 또는 명시한 size에 도달할 때까지 내용을 읽고 문자열의 일부를 반환
  - 리스트 = 파일.readlines()
    - 파일 안의 모든 텍스트 줄을 읽어 문자열 리스트로 반환
  - 파일.write(문자열)
    - 쓴 문자 혹은 바이트 개수를 반환, 개행 문자는 직접 추가해야 함 
  - 파일.writelines(문자열|문자열리스트)
<br>

## 8.8 파일 포인터('seek') 사용하기
- 임의 접근을 할 수 있는 파일을 열었다면, seek와 tell 메서드를 사용하여 파일 내 원하는 위치로 이동할 수 있다.
  - 파일.seekable() : 파일 시스템이나 장치가 임의 접근 연산이 가능한지 확인
  - 파일.seek(pos, orig) : 원하는 위치로 파일 포인터를 이동
    - pos : offset으로, 0,1,2 중 하나의 값을 넣을 수 있다. (각각 파일의 시작, 현재 위치, 끝을 의미)
    - orig : origin (파일의 시작을 의미하는 0으로 설정)
  - 파일.tell() : seek 메서드와 정반대로, 파일 시작부터 찾는 대상까지의 바이트 갯수를 확인할 수 있는 오프셋 숫자를 반환
<br>

## 8.9 RPN 프로젝트 안에서 텍스트 읽기
- 생략
<br>

## 8.10 바이너리 직접 읽기/쓰기
- 파이썬 저수준(low-level) 바이너리 읽기/쓰기 연산은 텍스트-파일 연산과 비슷하지만 bytes 데이터를 다룬다
  - 바이트_문자열 = 파일.read(size=-1)
  - 파일.write(바이트_문자열)
<br>

## 8.11 데이터를 고정-길이 필드로 변환(struct)
- struct 패키지는 바이트 문자열 안에 익숙한 내장 타입을 패킹하거나 언패킹하는 데에 도움을 주는 도구이다.
- struct.pack(포맷_문자열, v1, v2, v3, ...) : 바이너리 파일에 쓸 수 있는 bytes 문자열을 반환한다.
  - 포맷 문자열과 1개 이상의 값을 인수로 받는다. 
- v1, v2, v3, ... = struct.unpack(포맷_문자열, 바이트_문자열) : 타입 bytes의 문자열을 인수로 받아서 튜플로 여러 값을 반환한다.
- calcsize : 주어진 포맷 문자열이 요구하는 바이트를 반환
(이하 생략)
<br>

## 8.12 피클링 패키지 사용하기
- 피클링 인터페이스는 훨씬 쉽게 데이터 파일을 읽고 쓰는 방법을 제공한다.
- 피클 데이터 파일은 파이썬 객체의 나열로 구성되어있고, 각 객체는 일종의 '블랙박스'로 피클링으로 읽거나 쓴다.
- 피클링은 아래의 2개 함수로 수행한다. 이 방법을 사용하면 한 번에 하나씩 파이썬 객체를 읽고 쓰기만 하면 된다.
  - pickle.dump(value, file_obj) : 파일에 객체 쓰기
  - value = pickle.load(file.obj) : 파일에서 객체 불러오기
- 단 하나 고려할 제약사항은 파일에 얼마나 많은 객체가 있는지 알 수 없다는 것이다.
  - 프로그램에 EOFError를 발생시킬 때까지 최대한 많은 객체를 불러오는 방법이 있다.
<br>

## 8.13 shelve 패키지 사용하기
- shelve 패키지는 pickle 인터페이스를 기반으로 파일와이드 데이터베이스를 구축한다.
- 이 패키지의 인터페이스는 단순하다. shelve.open으로 파일을 열고, 반환된 객체는 가상 딕셔너리로 사용한다.
  - shelf_obj = shelve.open(db_name)
- 딕셔너리 연산을 수행한 후, close 메서드를 호출하여 디스크에 기록하면 원하는 작업이 완료된다.
<br>














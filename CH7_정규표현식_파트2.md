# 7. 정규표현식 파트2
<br>

## 7.1 고급 정규표현식 문법의 요약
- 정규표현식 고급 문법 요약 (추후 이어지는 절에서 각 기능에 대해 자세히 설명할 것)
  - (?:expr) : 태그가 없는 그룹 (일치조건에 만족하더라도 그룹으로 기록되지 않는 패턴)
  - expr?? : ? 연산자의 게으른(non-greedy) 버전
  - expr*? : 게으른 일치를 사용, expr이 0회 이상 나타나는지 확인
  - expr+? : 게으른 일치를 사용, expr이 1회 이상 나타나는지 확인
  - expr{m}? : {m} 연산자의 게으른 버전, 탐욕적 버전과 똑같이 동작
  - expr{m,n}? : {m,n} 연산자의 게으른 버전
  - (?=expr) : 긍정적 전방탐색
  - (?!expr) : 부정적 전방탐색
  - (?<=expr) : 긍정적 후방탐색
  - (?<!expr) : 부정적 후방탐색
  - (?P<name\>expr) : 명명그룹 (expr이 일치하면 전체 표현식이 일치)
  - (?P=name) : 명명그룹 테스트
  - (#text) : 주석 (정규표현식 안에 나타날 수 있지만 검사기가 내용을 무시함)
  - (?(name)yes_pat|no_pat) : 조건적 일치
  
<br>

## 7.2 태그를 남기지 않는 그룹
### 7.2.1 표준 숫자 예시
- 천 단위 그룹 구분자(,)를 포함한 미국식 포맷으로 작성된 숫자만 허용하는 패턴이 있다고 하자.
  - r'\d{1,3}(,\d{3})\*(\.\d\*)?'
  - \b(단어 경계)를 패턴 맨 뒤에 추가해서 아래와 같은 경우와 일치하지 않도록 한다.
    - 1,20123
    - 근데 이렇게 해도 1,20.00 의 경우에서 20.00을 패턴과 일치하는 경우로 검출하는 오류가 있긴 함
<br>

### 7.2.2 태깅 문제 고치기
- 태그가 붙은 그룹은 re.findall의 동작을 변경하므로 문제가 된다.
  - 위 숫자패턴 예시에서의 첫번째 해결방법은 전체 패턴을 그룹화(태깅)하는 것이다.
  - 그리고 여기서 제시하는 두번째 방법은 태깅을 아예 하지 않는 것이다.
    - (?:expr) : expr를 하나의 단위로 인식하지만, 패턴이 일치하더라도 일치한 문자를 태그로 남기지 않음
<br>

## 7.3 탐욕적 일치 vs 게으른 일치
- 탐욕적(greedy) 일치와 게으른(lazy) 일치의 차이를 보여주는 예시
  - HTML 헤더에서 특정 텍스트를 찾는 문제가 있고, 아래와 같은 문자열에서 선형괄호(<\>)안의 텍스트를 찾고 싶다고 하자.
    - the_line = '<h1\>Heading</h1\>'
  - 이 경우의 정규표현식 검색 패턴은 아래와 같을 것이다.
    - pat = r'<.*\>'
  - 우리가 원하는 결과는 '<h1\>'이지만, 결과는 '<h1\>Heading</h1\>'이다.
    - 이유는 탐욕적 일치를 택했기 때문이다.
    - 탐욕적 일치는 패턴과 일치하는 텍스트가 여러개라면 가능한 한 많은 텍스트와 일치하는 것을 선택한다.
    - 게으른 일치는 이와 다르게, 처음 만나는 선형괄호에서 멈출 것이다.
      - 이런 게으른 일치를 명시하기 위해서는 더하기 기호나 별표 기호 뒤에 물음표 기호를 붙이면 된다. (lazy_pat = r'<.\*?\>'
      - 문장의 수를 셀 때는 아래의 예시를 활용하자.

```python
s = '''Here is a single sentence. Here is
another sentence, ending in a period. And 
here is yet another.'''

# 문장이 끝나는 기호가 오기 전에 0개 이상의 단어가 등장하는 패턴 = 문장 찾기
# 여러 개의 문장이 연결되어 있으면 lazy하게 찾아야 모든 문장을 다 찾으므로, \* 뒤에 ?를 붙여준다 
pat = r'.*?[.?!]'

# re.DOTALL 플래그는 점 기호 메타문자가 문자열의 끝이 아닌 개행문자로 인식되게 한다 (더 짧게 쓰려면 re.S로 쓸 수 있음)
lst = re.findall(pat, s, flags=re.DOTALL)
print(list)
```
<br>

## 7.4 전방탐색 기능
- 문장 개수 세기 예시를 다시 보자.
  - 점 기호를 사용하는 약어(U.S.A)나 소수점은 문장의 끝을 의미하지 않으므로 문제가 된다.
  - 위의 예외를 무시하고 문장을 제대로 인식하는 패턴을 정의하기 위해 전방탐색 규칙을 활용한다.
<br>

- (?=expr)
  - 현재 위치의 '바로 다음 문자'를 expr과 비교해서 전방탐색 패턴에 응답한다.
  - expr의 문자들은 태그되지 않고, put back하여 다시 읽어야할 대상으로 만든다. 
<br>

- 다시 문장을 제대로 읽기 위해 필요한 조건을 나열해보자.
  - 일단 대문자를 찾는다. : \[A-Z]
  - 다음 조건 중 하나라도 만족하면, 다음 시도까지 게으른 일치를 사용하여 문자를 읽는다.
    - 다른 대문자가 뒤따르는 빈칸이 나타난다. :  \[A-Z]
    - 문자열의 끝이 나타난다. : $
  - 이를 모두 합쳐 정확한 정규표현식 패턴을 만들면 아래와 같다.
    - r'\[A-Z].*?\[.!?](?= [A-Z]|$)'
    - 전방일치 조건을 만나지 못하면 문장은 끝난 것이 아니며, 멈추지 않고 다음 텍스트를 읽게 된다.
<br>

- 문장의 마지막 문자를 읽는 것(구두점 기호)와 전방탐색 조건의 문자의 차이점?
  - **전방탐색 조건을 만족하는 글자는 문장의 일부가 아니다!**
  - 다음에 읽기 위해 남겨야 할 문자를 소비하지 않는다는 의미이다. (예를 들면 두번째 문장의 첫 대문자같은 것)
<br>

## 7.5 다중 패턴 확인하기 (전방탐색)
- 여러 가지 조건을 동시에 확인하는 것도 가능하다.
  - 조건이 n개라면, n개의 전방탐색 조건을 만들고 그 패턴을 전체 패턴의 앞에 위치하게 한다.
  - 그렇게하면 모든 조건을 확인하면서도 검사한 문자를 소비하지는 않게 된다.
  - 예를 들어, 아래와 같이 비밀번호의 조건 여러 개를 전방탐색하게 만들 경우, re.match를 한번만 호출하므로 효율적이다.

```python

pat1 = r'(\w|[!@#$%^&*+-]){8,12}$'
pat2 = r'(?=.*[a-zA-Z])'
pat3 = r'(?=.*\d)'
pat4 = r'(?=.*[!@#$%^&*+-])'

pat = pat2 + pat3 + pat4 + pat1

import re
passwd = 'HenryThe5!'
if re.match(pat, passwd):
  print('It passed the test!')
else:
  print('Insufficiently strong password.')

```
<br>

## 7.6 부정적 전방탐색
- 부정적 전방탐색은 다음 문자가 특정 하위 패턴에 일치하지 않았을 때 성공한다.
- (?!expr)
  - 읽을 다음 문자가 expr과 일치하지 않는 경우에만 일치를 허용한다.
<br>

## 7.7 명명 그룹
- 태그를 붙인 그룹은 숫자로 접근 가능하지만, 복잡한 정규표현식을 다룬다면 숫자가 아닌 이름으로 태그 그룹을 참조하는 것이 좋다.
- 이런 경우에 명명 그룹을 사용한다.
<br>

- (?P\<이름>표현식) : 이름을 사용하여 일치한 그룹에 태그를 남긴다.
- (?P=이름) : 명명 그룹의 반복으로 일치 유무를 판단한다.
<br>

- 예시를 통해 이해해보자. 
- 영문 이름을 이름-성 순이 아닌 성-이름 순으로 바꾸어 저장하는 문제 
```python

# middle name까지 모두 고려한 패턴
# 선택적으로 중간 이름 머리글자를 인식할 수 있음
# 여기서 그룹의 이름은 각각 first, mid, last가 된다
pat = r'(?P\<first>\w+) (?P\<mid>\w\. )?(?P\<last>\w+)'

# 패턴을 이름으로 나누고, 출력 형식을 자유롭게 변경할 수 있다
# 순서에 상관없이 이름으로 명명하므로, 항상 발생하지 않는 경우의 그룹을 쉽게 관리할 수 있다
def reorg_name(in_s):
  m = re.match(pat, in_s)
  s = m.group('last') + ', ' + m.group('first')
  if m.group('mid'):
    s += ' ' + m.group('mid')
  return s
  
```
<br>

- 이미 태그로 기록된 문자열을 반복하여 요청할 수도 있다.
  - 6장에서는 숫자를 사용하여 반복 참조하는 방법을 보였다.
    - pat = r'(\w+) \1'
  - 이를 명명 그룹 버전으로 바꾸면 다음과 같다.
    - pat = r'(?P\<word>\w+) (?P=word)'
<br>

## 7.8 re.split 함수
- 텍스트를 토큰으로 쪼개는 데에 도움을 주는 정규표현식 : re.split 함수를 사용하기.
  - 리스트 = re.split(패턴, 문자열, maxsplit=0, flags=0)
  - 패턴은 토큰 구분자를 표현한 것이다.
  - 문자열은 토큰으로 나눌 대상 문자열이다.
<br>

## 7.9 스캐너 클래스와 RPN 프로젝트
- re.Scanner 클래스는 자체 스캐너 객체를 만들 수 있게 해준다.
<br>

```python
scanner_name = re.Scanner([
  (토큰_패턴1, 함수1),
  (토큰_패턴2, 함수2),
  # 패턴과 함수는 얼마든지 더 추가할 수 있음
  # 패턴이 제시된 순서대로 읽히므로, 먼저 읽어야되는 패턴이 위에 와야 함
  ])
```
<br>

- 토큰_패턴은 인식할 토큰을 묘사할 정규표현식
- 함수는 사전 정의된 함수이거나 익명의 람다 함수
  - 함수_이름(스캐너, 토큰_문자열)
    - 스캐너는 스캐너 객체 자체를 참조하는 것
    - 토큰_문자열은 토큰을 담고있는 부분 문자열
<br>

```python

# RPN 예시

def sc_oper(scanner, tok): return tok
def sc_int(scanner, tok): return int(tok)
def sc_float(scanner, tok): return float(tok)

scanner = re.Scanner([
  (r'[*+/-]', sc_oper),
  # 소수점이 들어있는 토큰을 먼저 발견해서 괜히 앞부분만 정수로 처리되지 않도록 함
  (r'\d+\.\d*', sc_float),
  (r'\d+', sc_int)
  ])

```
<br>

- 이렇게 정의한 코드로 함수 scanner.scan을 호출할 수 있게 된다.
  - scan을 호출하면 스캐너가 대상 문자열을 스캔, 작성한 프로그램에 따라 객체들을 반환한다.
  - 이 함수는 2개의 출력값을 담은 튜플을 반환한다.
    - 첫번째 값은 함수에 의해 반환된 모든 토큰을 담은 리스트
    - 두번째 값은 성공적으로 스캔되지 않은 텍스트를 담고 있는 문자열
<br>

## 7.10 RPN:스캐너로 더 많은 작업 수행하기

```python

import re
import operator

the_stk = []

scanner = re.Scanner([
  (r'[+]', lambda s,t: bin_op(operator.add)),
  (r'[*]', lambda s,t: bin_op(operator.mul)),
  (r'[-]', lambda s,t: bin_op(operator.sub)),
  (r'[/]', lambda s,t: bin_op(operator.truediv)),
  (r'\d+\.\d*', lambda s,t: the_stk.append(float(t))),
  (r'\d+', lambda s,t: the_stk.append(int(t))),
  (r'\s+', None)
  ]) 
  
def bin_op(oper):
  op2, op1 = the_stk.pop(), the_stk.pop()
  the_stk.append(oper(op1, op2))

def main():
  input_str = input('Enter RPN string: ')
  tokens, unknown = scanner.scan(input_str)
  if unknown:
    print('Unrecognized input:', unknown)
  else :
    print('Answer is', the_stk.pop())
    
main()

```

